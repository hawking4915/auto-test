"""
@Version: 1.0
@Project: BeautyReport
@Author: Raymond
@Data: 2017/11/15 下午5:28
@File: __init__.py.py
@License: MIT
"""
from method.out_log import logger
import os
from PIL import Image
import sys
from io import StringIO as StringIO
import time
import json
import unittest
import platform
import base64
from distutils.sysconfig import get_python_lib
import traceback
from functools import wraps

__all__ = ['BeautifulReport']

HTML_IMG_TEMPLATE = """
    <a href="data:image/png;base64, {}">
    <img src="data:image/png;base64, {}" width="800px" height="500px"/>
    </a>
    <br></br>
"""

class OutputRedirector(object):
    """ Wrapper to redirect stdout or stderr """
    
    def __init__(self, fp):
        self.fp = fp
    
    def write(self, s):
        self.fp.write(s)
    
    def writelines(self, lines):
        self.fp.writelines(lines)
    
    def flush(self):
        self.fp.flush()


stdout_redirector = OutputRedirector(sys.stdout)
stderr_redirector = OutputRedirector(sys.stderr)

SYSSTR = platform.system()
SITE_PAKAGE_PATH = get_python_lib()

FIELDS = {
    "testPass": 0,
    "testResult": [
    ],
    "testName": "",
    "testAll": 0,
    "testFail": 0,
    "testErro": 0,
    "beginTime": "",
    "totalTime": "",
    "testSkip": 0
}


class PATH:
    """ all file PATH meta """
    config_tmp_path = SITE_PAKAGE_PATH + '/BeautifulReport/template/template'


class MakeResultJson:
    """ make html table tags """
    
    def __init__(self, datas: tuple):
        """
        init self object
        :param datas: 拿到所有返回数据结构
        """
        self.datas = datas
        self.result_schema = {}
    
    def __setitem__(self, key, value):
        """
        
        :param key: self[key]
        :param value: value
        :return:
        """
        self[key] = value
    
    def __repr__(self) -> str:
        """
            返回对象的html结构体
        :rtype: dict
        :return: self的repr对象, 返回一个构造完成的tr表单
        """
        keys = (
            'className',
            'methodName',
            'description',
            'spendTime',
            'status',
            'log',
            'httpStatus',
            'code',
        )
        for key, data in zip(keys, self.datas):
            self.result_schema.setdefault(key, data)   #组合成字典
        return json.dumps(self.result_schema)      #序列化json串


class ReportTestResult(unittest.TestResult):
    """ override"""
    
    def __init__(self, suite, stream=sys.stdout):
        """ pass """
        super(ReportTestResult, self).__init__()
        self.begin_time = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        self.start_time = 0
        self.stream = stream
        self.end_time = 0
        self.failure_count = 0
        self.error_count = 0
        self.success_count = 0
        self.skipped = 0
        self.verbosity = 1
        self.success_case_info = []
        self.skipped_case_info = []
        self.failures_case_info = []
        self.errors_case_info = []
        self.all_case_counter = 0
        self.suite = suite
        self.status = ''
        self.result_list = []
        self.case_log = ''
        self.default_report_name = '自动化测试报告'
        self.FIELDS = None
        self.sys_stdout = None
        self.sys_stderr = None
        self.outputBuffer = None
        self.httpStatus = 'Null' #新增类变量
        self.code = 'Null'

    def get_httpStatus(self, logstr):
        """ 新增函数--获取响应状态码httpStatus """
        pattern = re.compile(r'"httpStatus":([0-9]+)')
        httpStatus = pattern .findall( logstr)[0]
        return httpStatus

    def get_code(self, logstr):
        """ 新增函数--获取响应code """
        pattern = re.compile(r'"code":([0-9]+)')
        code = pattern .findall( logstr)[0]
        return code

    @property
    def success_counter(self) -> int:
        """ set success counter """
        return self.success_count
    
    @success_counter.setter
    def success_counter(self, value) -> None:
        """
            success_counter函数的setter方法, 用于改变成功的case数量
        :param value: 当前传递进来的成功次数的int数值
        :return:
        """
        self.success_count = value
    
    def startTest(self, test) -> None:
        """
            当测试用例测试即将运行时调用
        :return:
        """
        unittest.TestResult.startTest(self, test)
        self.outputBuffer = StringIO()
        stdout_redirector.fp = self.outputBuffer
        stderr_redirector.fp = self.outputBuffer
        self.sys_stdout = sys.stdout
        self.sys_stdout = sys.stderr
        sys.stdout = stdout_redirector
        sys.stderr = stderr_redirector
        self.start_time = time.time()

    def complete_output(self):
        """
        Disconnect output redirection and return buffer.
        Safe to call multiple times.
        """
        if self.sys_stdout:
            sys.stdout = self.sys_stdout
            sys.stderr = self.sys_stdout
            self.sys_stdout = None
            self.sys_stdout = None
        return self.outputBuffer.getvalue()

    def stopTest(self, test) -> None:
        """
            当测试用力执行完成后进行调用
        :return:
        """
        self.end_time = '{0:.3} s'.format((time.time() - self.start_time))
        self.result_list.append(self.get_all_result_info_tuple(test))
        self.complete_output()

    def stopTestRun(self, title=None) -> dict:
        """
            所有测试执行完成后, 执行该方法
        :param title:
        :return:
        """
        FIELDS['testPass'] = self.success_counter  #成功用例数
        for item in self.result_list:
            item = json.loads(str(MakeResultJson(item)))
            FIELDS.get('testResult').append(item)
        FIELDS['testAll'] = len(self.result_list)  #用例总数
        FIELDS['testName'] = title if title else self.default_report_name  #title名称
        FIELDS['testFail'] = self.failure_count #失败用例数
        FIELDS['beginTime'] = self.begin_time   #开始时间
        end_time = int(time.time())
        start_time = int(time.mktime(time.strptime(self.begin_time, '%Y-%m-%d %H:%M:%S')))
        FIELDS['totalTime'] = str(end_time - start_time) + 's' #执行总时间（结束时间-开始时间）
        FIELDS['testErro'] = self.error_count   #报错用例数
        FIELDS['testSkip'] = self.skipped       #跳过用例数
        self.FIELDS = FIELDS
        return FIELDS
    
    def get_all_result_info_tuple(self, test) -> tuple:
        """
            接受test 相关信息, 并拼接成一个完成的tuple结构返回
        :param test:
        :return:
        """
        return tuple([*self.get_testcase_property(test), self.end_time, self.status, self.case_log , self.httpStatus, self.code])
    
    @staticmethod
    def error_or_failure_text(err) -> str:
        """
            获取sys.exc_info()的参数并返回字符串类型的数据, 去掉t6 error
        :param err:
        :return:
        """
        return traceback.format_exception(*err)

    def addSuccess(self, test) -> None:
        """
            pass
        :param test:
        :return:
        """
        logs = []
        unittest.TestResult.addSuccess(self, test)#
        output = self.complete_output()
        # 新增代码--如果能够抓到httpStatus则赋值给类变量httpStatus,若没有抓到，httpStatus还是为Null
        try:
            httpStatus = self.get_httpStatus(output)
            code =  self.get_code(output)
            self.httpStatus= httpStatus
            self.code = code
        except:
            pass
        logs.append(output)
        self.success_counter += 1
        self.add_test_type('通过', logs)
        if self.verbosity > 1:
            sys.stderr.write('ok ')
            sys.stderr.write(str(test))
            sys.stderr.write('\n')
        else:
            sys.stderr.write('.')
        self.status = '通过'

        self._mirrorOutput = True  # print(class_name, method_name, method_doc)

    def addError(self, test, err):
        """
            add Some Error Result and infos
        :param test:
        :param err:
        :return:
        """
        logs = []
        unittest.TestResult.addError(self, test, err)
        _, _exc_str = self.errors[-1]
        output = self.complete_output()
        # 新增代码--如果能够抓到httpStatus则赋值给类变量httpStatus,若没有抓到，httpStatus还是为Null
        try:
            httpStatus = self.get_httpStatus(output)
            code = self.get_code(output)
            self.httpStatus = httpStatus
            self.code = code
        except:
            pass
        logs.append(output)
        logs.extend(self.error_or_failure_text(err))
        # logs.extend(_exc_str)
        self.error_count += 1
        self.add_test_type('错误',logs)
        if self.verbosity > 1:
            sys.stderr.write('E  ')
            sys.stderr.write(str(test))
            sys.stderr.write('\n')
        else:
            sys.stderr.write('E')
        self.status = '错误'

        self._mirrorOutput = True   # print(class_name, method_name, method_doc)
    
    def addFailure(self, test, err):
        """
            add Some Failures Result and infos
        :param test:
        :param err:
        :return:
        """
        logs = []
        unittest.TestResult.addFailure(self, test, err)
        _, _exc_str = self.failures[-1]
        output = self.complete_output()
        # 新增代码--如果能够抓到httpStatus则赋值给类变量httpStatus,若没有抓到，httpStatus还是为Null
        try:
            httpStatus = self.get_httpStatus(output)
            code = self.get_code(output)
            self.httpStatus = httpStatus
            self.code = code
        except:
            pass
        logs.append(output)
        logs.extend(self.error_or_failure_text(err))
        # logs.extend(_exc_str)
        self.failure_count += 1
        self.add_test_type('失败', logs)
        if self.verbosity > 1:
            sys.stderr.write('F  ')
            sys.stderr.write(str(test))
            sys.stderr.write('\n')
        else:
            sys.stderr.write('F')
        self.status = '失败'
        
        self._mirrorOutput = True   # print(class_name, method_name, method_doc)
    
    def addSkip(self, test, reason) -> None:
        """
            获取全部的跳过的case信息
        :param test:
        :param reason:
        :return: None
        """
        logs = [reason]
        self.complete_output()
        self.skipped += 1
        self.add_test_type('跳过', logs)
        if self.verbosity > 1:
            sys.stderr.write('S  ')
            sys.stderr.write(str(test))
            sys.stderr.write('\n')
        else:
            sys.stderr.write('S')
        self.status = '跳过'
        self._mirrorOutput = True   # print(class_name, method_name, method_doc)
    
    def add_test_type(self, status: str, case_log: list) -> None:
        """
            abstruct add test type and return tuple
        :param status:
        :param case_log:
        :return:
        """
        self.status = status
        self.case_log = case_log
    
    @staticmethod
    def get_testcase_property(test) -> tuple:
        """
            接受一个test, 并返回一个test的class_name, method_name, method_doc属性
        :param test:
        :return: (class_name, method_name, method_doc) -> tuple
        """
        class_name = test.__class__.__qualname__
        method_name = test.__dict__['_testMethodName']
        method_doc = test.__dict__['_testMethodDoc']
        return class_name, method_name, method_doc


class BeautifulReport(ReportTestResult, PATH):
    img_path = 'img/' if platform.system() != 'Windows' else 'img\\'
    #platform.system()返回系统/操作系统名称,例如“Linux”,“Windows”或“Java”。如果无法确定该值,则返回空字符串。
    #platform.system() != 'Windows' 条件为真则结果为：'img/'；条件为假则结果为：'img\\'
    def __init__(self, suites):
        super(BeautifulReport, self).__init__(suites)
        self.suites = suites
        self.log_path = None
        self.title = None
        self.filename = None

    def report(self,log_path, description , filename: str = None, ):
        """
            生成测试报告,并放在当前运行路径下
        :param log_path: 生成report的文件存储路径
        :param filename: 生成文件的filename
        :param description: 生成文件的注释
        :return:
        """
        if filename:
            filename_new = time.strftime('%Y%m%d_%H%M%S',time.localtime(time.time()))+'_'+ filename
            self.filename = filename_new if filename_new.endswith('.html') else filename_new + '.html'
        
        if description:
            self.title = description

        self.log_path = os.path.abspath(log_path)
        self.suites.run(result=self)
        self.stopTestRun(self.title)
        self.output_report()
        logger.info("*************************  Test Ending  *************************")
        # report_path = "{}".format(self.log_path+'\\'+self.filename)
        report_path = self.log_path + '\\' + self.filename
        return report_path

    def output_report(self):
        """
            生成测试报告到指定路径下
        :return:
        """
        template_path = self.config_tmp_path    #前端模板路径
        override_path = os.path.abspath(self.log_path) if \
            os.path.abspath(self.log_path).endswith('/') else \
            os.path.abspath(self.log_path) + '/'     #判断log_path后缀是否有/
        
        with open(template_path, 'rb') as file:      #读取前端文件
            body = file.readlines()
        with open(override_path + self.filename, 'wb') as write_file:
            for item in body:
                if item.strip().startswith(b'var resultData'):
                    head = '    var resultData = '
                    item = item.decode().split(head)
                    item[1] = head + json.dumps(self.FIELDS, ensure_ascii=False, indent=4)
                    item = ''.join(item).encode()
                    item = bytes(item) + b';\n'
                write_file.write(item)
    

    def img2base(img_path: str, file_name: str) -> str:
        """
            接受传递进函数的filename 并找到文件转换为base64格式
        :param img_path: 通过文件名及默认路径找到的img绝对路径
        :param file_name: 用户在装饰器中传递进来的文件匿名
        :return:
        """
        pattern = '/' if platform.system() != 'Windows' else '\\'

        srcFile = img_path + pattern + file_name
        if os.path.isfile(srcFile):
            try:
                # 打开原图片缩小后保存，可以用if srcFile.endswith(".jpg")或者split，splitext等函数等针对特定文件压缩
                sImg = Image.open(srcFile)
                w, h = sImg.size    # 获取宽度,高度
                dImg = sImg.resize((int(w / 3), int(h / 3)), Image.ANTIALIAS)  # 设置压缩尺寸和选项，注意尺寸要用括号
                dImg.save(srcFile)  # 可以用srcFile原路径保存,或者更改后缀保存，save这个函数后面可以加压缩编码选项JPEG之类的
            except Exception:
                raise

        with open(srcFile, 'rb') as file:
            data = file.read()
        return base64.b64encode(data).decode()

    @staticmethod
    def save_img(driver,img_name):
        img_path = 'img'
        img_name_new = time.strftime('%Y%m%d_%H%M%S', time.localtime(time.time())) + '_' + img_name
        driver.get_screenshot_as_file('{}/{}.png'.format(img_path, img_name_new))
        return img_name_new

    @staticmethod
    def img_writeHTML(*args):
        files = os.listdir(args[0])
        if len(args[1]) >= 1:
            for parg in args[1]:
                pargs_new = []
                for parg_new in files:
                    # 由于add_test_img中有参数driver，type不是字符串，直接判断会报错TypeError: 'in ' requires string as left operand, not WebDriver
                    if str(parg) in parg_new and parg_new.endswith('.png'):
                        pargs_new.append(parg_new)
                    else:
                        pass
                # 测试用例1执行完之后不走登陆失败截图函数，pargs_new为空，无截图'登录失败-登录页面'，pargs_new[-1]代码会报错
                # 增加判空-解决if-else，但是无新截图有旧截图时，在新运行脚本时新测试报告还是会写入旧截图（解决：534-535）
                if len(pargs_new):
                    pargs_new.sort()
                    print("<p>手动截图 : %s</p>" % pargs_new[-1])
                    data = BeautifulReport.img2base(args[0], pargs_new[-1])
                    print(HTML_IMG_TEMPLATE.format(data, data))

    #该函数GUI截图函数，程序报错/Fail会截图写入测试报告，程序需要手动截图，则在该函数加参数+测试脚本中加对应数量的save_img函数，不需要手动截图参数为空
    def add_test_img(*pargs):
        '''
            接受若干个图片元素, 并展示在测试报告中
        :param pargs:
        :return:
        '''
        def _wrap(func):
            @wraps(func)
            def __wrap(*args, **kwargs):
                #img_path:截图位置的绝对路径    os.path.abspath()：返回一个目录的绝对路径
                img_path = os.path.abspath('{}'.format(BeautifulReport.img_path))
                try:
                    #测试结果pass，testest_GUI_TS_Login_073_OAuth函数无return，返回为None
                    result = func(*args, **kwargs) #result 是func 函数调用后的结果赋值给result 变量
                    BeautifulReport.img_writeHTML(img_path,pargs)
                    return result
                except Exception as e:
                    #代码报错/测试结果Fail，失败截图
                    #func.__name__为测试用例名称,test开头的方法
                    if "driver" in dir(args[0]):
                        driver = getattr(args[0], 'driver')
                        parg_new_fail = BeautifulReport.save_img(driver, "失败截图")
                        print("<p>失败截图 : %s.png </p>" % parg_new_fail)
                        data = BeautifulReport.img2base(img_path, parg_new_fail + '.png')
                        print(HTML_IMG_TEMPLATE.format(data, data))
                    BeautifulReport.img_writeHTML(img_path, pargs)
                    raise
                print('<br></br>')

                #测试结果pass/fail，将手动截图写入html文件中
                #files：img文件夹中所有图片名称，列表形式
                #pargs：add_test_img的参数，参数名称唯一性

                #将add_test_img的参数逐一与img文件夹中所有图片名称进行匹配，将最新时间的图片写入
                # 如果测试结果pass走try，以下return result不会报错
                # 如果测试结果fail走except，以下return result会报错：UnboundLocalError: local variable 'result' referenced before assignment
                # 原因：except中没有result
                #解决办法：手动截图方法封装分别放到try、except中
            return __wrap
        return _wrap

